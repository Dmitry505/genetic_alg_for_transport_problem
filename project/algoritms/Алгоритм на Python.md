# Генетический алгоритм для решения транспортной задачи

Этот документ предоставляет описание генетического алгоритма, реализованного на Python для решения транспортной задачи с фиксированными затратами.

## Обзор

Алгоритм решает транспортную задачу, находя оптимальный план перевозок, который минимизирует общую стоимость, включающую как переменные, так и фиксированные затраты. Для поиска наилучшего решения используется подход генетического алгоритма.

## Файлы

- `main.py`: Основной Python файл, реализующий генетический алгоритм и функции для поиска лучшего решения.

## Зависимости

- `numpy`
- `time`
- `random`

## Функции

### `genetic_algorithm_transportation(supply, demand, cost, fixed_cost, max_generations=1000, population_size=50, mutation_rate=0.01) -> tuple`

Решает транспортную задачу с использованием генетического алгоритма.

- `supply`: Список поставок от каждого поставщика.
- `demand`: Список спроса каждого потребителя.
- `cost`: Матрица стоимости перевозок.
- `fixed_cost`: Матрица фиксированных доплат.
- `max_generations`: Максимальное число поколений.
- `population_size`: Размер популяции.
- `mutation_rate`: Вероятность мутации.
- **Возвращает**: Кортеж, содержащий: решение в формате (Поставщик, Потребитель, Объем, Стоимость), общая оптимальная стоимость, время выполнения.

### `create_individual() -> np.array`

Создает индивидуальное решение (матрицу распределения поставок).

- **Возвращает**: Индивидуальное решение.

### `fitness(individual) -> float`

Вычисляет приспособленность (общую стоимость) индивидуального решения.

- `individual`: Индивидуальное решение.
- **Возвращает**: Общая стоимость решения.

### `crossover(parent1, parent2) -> np.array`

Выполняет кроссовер (скрещивание) двух родительских решений для создания потомка.

- `parent1`: Первое родительское решение.
- `parent2`: Второе родительское решение.
- **Возвращает**: Решение-потомок.

### `mutate(individual) -> np.array`

Выполняет мутацию индивидуального решения.

- `individual`: Индивидуальное решение.
- **Возвращает**: Модифицированное решение.

### `select_parent(population, fitnesses) -> np.array`

Выбирает родительское решение из популяции с учетом приспособленности.

- `population`: Популяция решений.
- `fitnesses`: Список приспособленностей.
- **Возвращает**: Выбранное родительское решение.

### `find_best_solution(supply, demand, cost, fixed_cost, max_generations=1000, population_size=50, mutation_rate=0.01, runs=10) -> tuple`

Выполняет генетический алгоритм несколько раз и возвращает лучшее решение.

- `supply`: Список поставок от каждого поставщика.
- `demand`: Список спроса каждого потребителя.
- `cost`: Матрица стоимости перевозок.
- `fixed_cost`: Матрица фиксированных доплат.
- `runs`: Количество запусков алгоритма.
- **Возвращает**: Кортеж, содержащий: лучшее решение в формате (Поставщик, Потребитель, Объем, Стоимость), общая оптимальная стоимость, общее время выполнения всех запусков.

## Пример использования

```python
if __name__ == '__main__':
    # Пример использования
    supply = [20, 30, 25]
    demand = [10, 15, 20, 30]
    cost = np.array([[8, 6, 10, 9],
                     [9, 12, 13, 7],
                     [14, 9, 16, 5]])
    fixed_cost = np.array([[1, 1, 2, 1],
                           [3, 2, 2, 3],
                           [4, 2, 3, 1]])

    best_results, best_fitness, total_execution_time = find_best_solution(supply, demand, cost, fixed_cost, runs=4)

    print("Оптимальный транспортный план:")
    print("Поставщик -> Потребитель | Размер поставки | стоимость")
    for result in best_results:
        supplier, consumer, amount, cost = result
        print(f"{supplier} -> {consumer} | {amount} | {cost:.2f}")

    print(f"\nОбщая оптимальная стоимость: {best_fitness:.2f}")
    print(f"Время выполнения : {total_execution_time:.2f} секунд")
   


Оптимальный транспортный план:
Поставщик -> Потребитель | Размер поставки | стоимость
0 -> 0 | 4 | 33.00
0 -> 1 | 16 | 97.00
1 -> 1 | 1 | 14.00
1 -> 3 | 29 | 206.00
2 -> 3 | 25 | 126.00

Общая оптимальная стоимость: 476.00
Время выполнения : 3.88 секунд
